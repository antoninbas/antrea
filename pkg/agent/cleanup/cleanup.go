// Copyright 2019 Antrea Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cleanup

import (
	"fmt"
	"io/ioutil"
	"os"

	"k8s.io/klog"

	"github.com/TomCodeLV/OVSDB-golang-lib/pkg/dbtransaction"
	"github.com/TomCodeLV/OVSDB-golang-lib/pkg/helpers"
	"github.com/vmware-tanzu/antrea/pkg/agent"
	"github.com/vmware-tanzu/antrea/pkg/ovs/ovsconfig"
	"gopkg.in/yaml.v2"
)

// agentConfig is a subset of the full agent configuration. It only includes the fields which are
// needed to clean-up the artifacts generated by the Antrea agent.
type agentConfig struct {
	CNISocket   string `yaml:"cniSocket,omitempty"`
	OVSBridge   string `yaml:"ovsBridge,omitempty"`
	HostGateway string `yaml:"hostGateway,omitempty"`
}

func loadConfig() (*agentConfig, error) {
	data, err := ioutil.ReadFile(agent.SavedConfigPath)
	if err != nil {
		return nil, err
	}

	var c agentConfig
	// we do not use UnmarshalStrict since we only care about a few fields
	// and therefore the agentConfig struct is missing a lot of
	// configuration fields.
	err = yaml.Unmarshal(data, &c)
	if err != nil {
		return nil, err
	}
	return &c, nil
}

// IsAgentCleanupNeeded
func IsAgentCleanupNeeded() (bool, error) {
	if _, err := os.Stat(agent.SavedConfigPath); err == nil {
		return true, nil
	} else if os.IsNotExist(err) {
		return false, nil
	} else {
		return false, fmt.Errorf("error when stat'ing file: %v", err)
	}
}

// TODO: avoid code duplication with ovs_client.go
func cleanupOVSBridge(bridgeName string) error {
	ovsdb, ovsErr := ovsconfig.NewOVSDBConnectionUDS("")
	if ovsErr != nil {
		return fmt.Errorf("error connecting to OVSDB: %v", ovsErr)
	}
	defer ovsdb.Close()

	lookupBridgeByName := func() (string, error) {
		tx := ovsdb.Transaction("Open_vSwitch")
		tx.Select(dbtransaction.Select{
			Table:   "Bridge",
			Columns: []string{"_uuid"},
			Where:   [][]interface{}{{"name", "==", bridgeName}},
		})
		res, err, _ := tx.Commit()
		if err != nil {
			return "", fmt.Errorf("error when looking up bridge %s", bridgeName)
		}

		if len(res[0].Rows) == 0 {
			return "", nil
		}

		uuid := res[0].Rows[0].(map[string]interface{})["_uuid"].([]interface{})[1].(string)
		return uuid, nil
	}

	uuid, err := lookupBridgeByName()
	if err != nil {
		return err
	}
	if uuid == "" {
		klog.Infof("OVS bridge %s does not exist", bridgeName)
		return nil
	}

	tx := ovsdb.Transaction("Open_vSwitch")
	mutateSet := helpers.MakeOVSDBSet(map[string]interface{}{
		"uuid": []string{uuid},
	})
	tx.Mutate(dbtransaction.Mutate{
		Table:     "Open_vSwitch",
		Mutations: [][]interface{}{{"bridges", "delete", mutateSet}},
	})

	if _, err, _ := tx.Commit(); err != nil {
		return fmt.Errorf("cannot delete OVS brigde %s, transaction failed: %v", bridgeName, err)
	}

	klog.Infof("OVS bridge %s deleted successfully", bridgeName)

	return nil
}

func AgentCleanup() error {
	config, err := loadConfig()
	if err != nil {
		return fmt.Errorf("error when parsing agent configuration: %v", err)
	}

	if err := cleanupOVSBridge(config.OVSBridge); err != nil {
		return err
	}

	// TODO(antonin)
	// * remove iptables rules
	// * remove /var/run/antrea
	// * ...

	return nil
}
